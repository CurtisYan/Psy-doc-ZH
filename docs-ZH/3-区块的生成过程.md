# 区块如何生成

从交易到区块证明的完整旅程

## Psy 网络：端到端区块生产之旅

对于开发者而言，理解 Psy 网络中交易与证明的完整生命周期——从用户的本地操作到最终生成一个全局可验证的区块——至关重要。本文档将追溯这一复杂精密的旅程，重点阐述不同网络参与者的角色，以及支撑 Psy 安全性与可扩展性的零知识证明（ZKP）流转过程。

整个过程可大致划分为四个主要阶段：

1. **阶段一：用户证明会话 (UPS) - 本地执行与证明生成**
2. **阶段二：领域节点级接收与初始聚合 (GUTA 入口)**
3. **阶段三：协调者级聚合与全局操作**
4. **阶段四：最终区块证明生成与最终化**

### 阶段一：用户证明会话 (UPS) —— 本地执行与证明生成

此阶段发生在用户的设备上或由用户选择的委托方执行。其目标是为即将到来的区块处理一批用户期望执行的交易，并生成一个紧凑且由用户授权的最终 ‘End Cap’ 证明，以证明这些交易的完整有效性。

**步骤 1.1: 会话初始化**

- **操作**: 用户（或其客户端软件）发起一次用户证明会话。
- **电路**: `UPSStartSessionCircuit` 在本地执行。
- **目的**: 为会话建立一个密码学安全且可验证的起点。
- **过程**:
  1. 用户的客户端从 Realm 或 Coordinator 获取最新已最终确定的全局 `CHKP` (检查点) 树根。
  2. 同时获取在该 `CHKP` 树根下，用户当前的 `ULEAF` (用户叶) 数据，该数据来自其所属的 `GUSR` (全局用户树) 分段。此 `ULEAF` 包含了用户的 `UCON` (用户合约树) 根以及 nonce、余额等元数据。
  3. `UPSStartSessionCircuit` 将这些数据（例如 `CHKP` 根、`ULEAF` 在 `GUSR` 中且锚定于该 `CHKP` 根的 Merkle 证明等）作为输入和见证。
  4. **证明内容**: 证明该会话始于一个对该用户有效的、全局公认的状态（即其 `ULEAF` 确实是所声明的 `CHKP` 根的一部分），并初始化会话的内部状态（例如，交易计数器置为0，债务树置空）。
  5. **输出**: 一个“开始会话”证明和一个初始的 `UserProvingSessionHeader`。该头部包含了 `session_start_context` (链接到全局 `CHKP` 根) 和 UPS 的 `current_state` (初始状态与起始状态一致，但更新了 `last_checkpoint_id`)。

**步骤 1.2: 本地合约函数执行与 CFC 证明生成 (为每笔交易重复此步骤)**

- **操作**: 用户希望包含的每一笔交易（例如，调用某个智能合约的函数）。
- **电路**: 对应于被调用智能合约函数的特定 `DapenContractFunctionCircuit` (CFC) 在本地执行。
- **目的**: 执行智能合约逻辑，并为*此次特定调用*（包括输入参数、当前用户 `CSTATE`）生成一个 ZK 证明。
- **过程**:
  1. 用户的客户端向 CFC 提供必要的输入：
     - `tx_ctx_header` (交易上下文头): 包含此次合约交互的*假定*起始状态（例如，该合约的用户 `CSTATE` 树根，该树根源自上一步 UPS 或会话开始时的 `UCON`）。
     - 智能合约函数的调用参数。
     - `session_proof_tree_root` (在此 UPS 中已构建的本地递归证明树的根)。
  2. Dapen 运行时在本地执行 CFC 逻辑，模拟对该合约的用户 `CSTATE` 状态的变更。
  3. **证明内容**: 证明 CFC 的内部操作严格遵循其已定义的代码，在给定输入下，将假定的 `start_contract_state_tree_root` 转换为 `end_contract_state_tree_root`，并产生所声明的输出。
  4. **输出**: 一个 CFC 证明和 `transaction_end_ctx` (包含结束状态的树根和输出哈希)。

**步骤 1.3: 将 CFC 集成至 UPS 并进行递归验证 (为每笔交易重复此步骤)**

- **操作**: 生成一个 CFC 证明后，将其集成到主 UPS 证明链中。
- **电路**: `UPSCFCStandardTransactionCircuit` (或用于延迟交易的变体，如 `UPSVerifyPopDeferredTxStepGadget`)。
- **目的**: 验证本地生成的 CFC 证明，确保其是一个合法且已注册的函数，并证明 UPS 的状态（用户的 `UCON` 根、债务树、交易计数器）根据 CFC 的执行结果被正确更新。同时，它会**递归地验证上一步 UPS 的证明**。
- **过程**:
  1. 输入/见证:
     - 上一步 UPS 的证明 (若是第一笔交易，则为“开始会话”证明)。
     - 上一步的 `UserProvingSessionHeader`。
     - 在步骤 1.2 中生成的 CFC 证明。
     - 状态更新的见证:
       - 一个用于更新用户 `UCON` 树的**增量 Merkle 证明** (证明特定 `contract_id` 对应的叶子从旧的 `CSTATE` 根更新为新的 `CSTATE` 根)。
       - 债务树的支点 Merkle 证明 (如适用)，证明其正确转换。
       - 合约函数被包含在全局 `GCON`/`CFT` 中的见证 (从 Realm/Coordinator 获取，并锚定于会话的 `CHKP` 根)。
  2. **证明内容**:
     - 上一步 UPS 的证明有效且使用了白名单内的 UPS 电路。
     - CFC 证明 (来自步骤 1.2) 有效，其函数在合约的 `CFT` 中全局注册 (对照会话的 `CHKP` 上下文进行验证)，且该 CFC 证明是同一 UPS 证明树的一部分。
     - `UPSCFCStandardStateDeltaInput` (源自 CFC 的 `tx_ctx_header`) 正确地关联到 CFC 已验证的计算。
     - 用户的 `UCON` 根根据 `user_contract_tree_update_proof` 被正确更新 (即，`UCON` 内特定合约的 `CSTATE` 根被更新)。
     - 债务树根正确转换。
     - 交易计数器递增，交易哈希栈被更新。
  3. **输出**: 一个新的 UPS 步骤证明和一个反映此交易后新状态的、更新后的 `UserProvingSessionHeader`。

**步骤 1.4: 会话最终化与签名**

- **操作**: 在本地处理完所有期望的交易后。
- **电路**: `UPSStandardEndCapCircuit` 在本地执行。
- **目的**: 安全地结束 UPS，生成最终的“End Cap”证明。此证明证实了整个本地交易证明序列的有效性，经用户的 ZK 签名授权，并确保会话在干净的状态下结束 (例如，无未偿还的债务)。
- **过程**:
  1. 输入/见证:
     - UPS 中最后一步交易的证明。
     - 最终的 `UserProvingSessionHeader`。
     - 一个 **ZK 签名证明**: 这是由用户选择的“签名电路”生成的证明。该签名电路的输入是一个**签名哈希 (sighash)** (源自 `PsyUserProvingSessionSignatureDataCompactGadget`，其中包含 `start_user_leaf_hash`, `end_user_leaf_hash`, `checkpoint_leaf_hash`, `tx_stack_hash`, `tx_count`, nonce 等)，并证明签名的条件已满足 (例如，若是传统密钥，则验证一个 ECC 签名；若是程序化密钥，则检查已定义的逻辑)。
  2. **证明内容**:
     - 最后一步 UPS 的证明有效且使用了白名单电路。
     - ZK 签名证明有效，且由一个其验证者数据哈希 (加上用户参数) 与用户注册公钥匹配的电路生成。
     - 签名证明中使用的签名哈希 (sighash) 与 UPS 的最终状态和交易摘要正确对应。
     - 用户的 nonce 在其最终的 `ULEAF` 中被正确递增。
     - 最终 `ULEAF` 中的 `last_checkpoint_id` 被正确更新为会话的 `checkpoint_id`。
     - 所有内部 UPS 债务树均为空。
  3. **输出**: End Cap 证明、其公共输入 (包括 `end_cap_result_hash` 和 `guta_stats_hash`)，以及**状态增量** (用户 `CSTATE` 树中实际变更的叶子节点的值)。

**步骤 1.5: 提交至 Realm**

- **操作**: 用户 (或客户端) 将生成的 End Cap 证明、其公共输入以及相关的状态增量，提交给负责其用户 ID 范围的 **Realm** 节点。这通常通过 Realm Edge API 完成。

### 阶段二：领域节点级接收与初始聚合 (GUTA 入口)

Realms 是网络上用户提交证明的第一个接触点。它们验证这些证明并开始聚合过程。

**步骤 2.1: End Cap 证明验证与 GUTA 头部创建**

- **操作**: 一个 Realm 节点接收来自用户的 End Cap 证明。
- **电路** (由证明矿工执行，Realm 编排):
  - `GUTAVerifySingleEndCapCircuit` (若独立处理一个 End Cap)
  - `GUTAVerifyTwoEndCapCircuit` (若处理一对 End Caps，这是聚合的常见起始情况)
- **目的**: 将用户的 End Cap 证明安全地纳入 GUTA 流程，对照协议规则和历史状态进行验证，并将其转换为标准的 `GlobalUserTreeAggregatorHeader` 格式。
- **过程**:
  1. Realm 将 End Cap 证明及其声明的结果/统计数据作为见证提供给证明矿工网络。它还提供一个 `checkpoint_historical_merkle_proof`，证明用户 UPS 所基于的 `checkpoint_tree_root` 确实是一个有效的、历史上的检查点。
  2. **证明内容** (在 GUTA 电路内):
     - End Cap 证明本身是一个有效的 ZK 证明。
     - 它是由官方已知的 `UPSStandardEndCapCircuit` 生成的 (通过指纹检查)。
     - 其公共输入与声明的 `end_cap_result` 和 `guta_stats` 相匹配。
     - `end_cap_result` 中声明的 `checkpoint_tree_root` 通过 `checkpoint_historical_merkle_proof` 得到验证。
     - (对于 `GUTAVerifyTwoEndCapCircuit`): 来自两个用户 End Caps 的状态转换 (例如，`GUSR` 中的 `start_leaf_A` -> `end_leaf_A` 和 `start_leaf_B` -> `end_leaf_B`)，使用一个 NCA (最近公共祖先) 证明见证，被正确地合并为它们在 `GUSR` 树中最近公共祖先处的单个状态转换。统计数据被累加。
  3. **输出**: 一个 `GlobalUserTreeAggregatorHeader`。该头部包含：
     - `guta_circuit_whitelist_root` (确保后续 GUTA 步骤使用有效电路)。
     - 此聚合步骤所锚定的 `checkpoint_tree_root` (这将是*当前*区块的目标 `CHKP` 根，源自历史证明)。
     - 一个 `SubTreeNodeStateTransition`，代表对 `GUSR` 的变更 (单个用户叶子更新或一个 NCA 父节点更新)。
     - 聚合后的 `GUTAStats`。
  4. Realm 同时存储用户的状态增量，并将其传递给对等的**数据可用性 (DA) 矿工**。

**步骤 2.2: 在 Realm 内部进行递归 GUTA 聚合**

- **操作**: Realm 继续编排对 `GlobalUserTreeAggregatorHeader` 的聚合。
- **电路** (由证明矿工执行):
  - `GUTAVerifyTwoGUTACircuit` (聚合两个 GUTA 子证明)
  - `GUTAVerifyLeftGUTARightEndCapCircuit` / `GUTAVerifyLeftEndCapRightGUTACircuit` (将一个 GUTA 子证明与一个新的 End Cap 证明聚合)
  - `GUTAVerifyGUTAToCapCircuit` (当无需合并时，使用“线证明”将 GUTA 证明沿树向上传递)
  - `GUTANoChangeCircuit` (处理子树中无用户活动的情况，确保检查点一致性)。
- **目的**: 在 Realm 的 `GUSR` 分段内，递归地组合已验证的状态转换，构建一个层级化的证明树。
- **过程**:
  1. 成对的 GUTA 头部 (或一个 GUTA 头部和一个新处理的 End Cap 头部) 被作为输入。
  2. **证明内容**:
     - 两个输入证明 (及其头部) 均有效，且使用了白名单内的 GUTA/EndCap 电路。
     - 两个输入证明引用了**完全相同**的 `checkpoint_tree_root` 和 `guta_circuit_whitelist_root`。
     - NCA 逻辑正确地将它们各自的 `GUSR` 状态转换合并为父节点处的新转换。
     - 统计数据被正确地累加。
  3. 此过程在 Realm 的 `GUSR` 分段树中向上重复进行，直到为该 Realm 分段的根生成一个**单一的 `GlobalUserTreeAggregatorHeader`** (及其对应的 GUTA 证明)。
- **输出**: 来自 Realm 的单一聚合 GUTA 证明，代表其分片内该区块的所有用户活动。

**步骤 2.3: 提交至 Coordinator**

- **操作**: Realm 将其最终的聚合 GUTA 证明 (及相关头部) 提交给 **Coordinator** 节点。

### 阶段三：协调者级聚合与全局操作

协调者聚合来自所有 Realms 的证明，并处理全局状态变更的证明。

**步骤 3.1: 聚合 Realm GUTA 证明**

- **操作**: 协调者接收来自多个 Realms 的 GUTA 证明。
- **电路** (由证明矿工执行，协调者编排): 主要是 `GUTAVerifyTwoGUTACircuit` 和 `GUTAVerifyGUTAToCapCircuit`。
- **目的**: 将每个 Realm 证明的状态转换合并为对整个 `GUSR` 树的证明。
- **过程**: 类似于步骤 2.2，但现在聚合的是代表整个 Realm 子树的证明。这个过程持续进行，直到获得一个针对全局 `GUSR` 根的单一 GUTA 证明。

**步骤 3.2: 处理全局操作**

- **操作**: 协调者还处理影响 `GUSR` 以外的全局树的操作。
- **电路** (由证明矿工执行，协调者编排):
  - **用户注册**: `BatchAppendUserRegistrationTreeCircuit`。证明将新用户公钥承诺批量追加到 `URT` (用户注册树) 的正确性。
  - **合约部署**: `BatchDeployContractsCircuit`。证明将新合约定义 (`CLEAF` 数据，包括 `CFT` 根) 批量追加到 `GCON` (全局合约树) 的正确性。
- **目的**: 为这些全局状态变更生成 ZK 证明。
- **输出**: `URT` 更新和 `GCON` 更新的证明。

**步骤 3.3: "第一部分"聚合 - 组合所有主要状态变更**

- **操作**: 协调者将聚合后的 GUTA 证明 (用于 `GUSR` 变更)、用户注册证明 (用于 `URT` 变更) 和合约部署证明 (用于 `GCON` 变更) 组合在一起。
- **电路** (由证明矿工执行，协调者编排): `VerifyAggUserRegistartionDeployContractsGUTACircuit`。
- **目的**: 创建一个单一的“第一部分”证明，该证明证实了该区块所有的主要状态树修改，并确保它们都与同一个底层的 `CHKP` 根 (来自前一个区块，用作用户会话和全局操作的基础) 保持一致。
- **证明内容**:
  - 输入的 GUTA 证明、用户注册证明和合约部署证明均有效，且使用了各自的白名单电路。
  - 所有这些证明都基于相同的历史 `CHKP` 根上下文。
- **输出**: 一个“第一部分”证明和一个 `VerifyAggUserRegistartionDeployContractsGUTAHeader`，该头部总结了 `GUSR` 根、`URT` 根和 `GCON` 根的净变化，以及聚合的 GUTA 统计数据。

### 阶段四：最终区块证明生成与最终化

这是将整个区块的有效性封装在一个证明中的最终步骤。

**步骤 4.1: 最终区块转换证明**

- **操作**: 协调者编排最终区块证明的生成。
- **电路** (由证明矿工执行，协调者编排): `PsyCheckpointStateTransitionCircuit`。（💡 *该电路对应区块链中的最终区块状态转换验证，类似于递归 SNARK 链的“末端封装层”。*）
- **目的**: 为当前区块生成决定性的 ZK 证明。此证明验证了阶段三的所有聚合工作，计算出新的全局状态根，形成新的 `PsyCheckpointLeaf`，证明其被正确地追加到 `CHKP` 树，并且至关重要地，**验证前一个区块的 `PsyCheckpointStateTransitionCircuit` 证明**。
- **过程**:
  1. 输入/见证:
     - “第一部分”证明及其头部 (来自步骤 3.3)。
     - 前一个区块的 `PsyCheckpointStateTransitionCircuit` 证明 (除非是创世区块)。
     - `previous_block_chkp_root` (此电路的公共输入，取自前一区块已最终确定的 `CHKP` 根)。
     - 新区块元数据的见证，如 `block_time` 和 `final_random_seed_contribution`。
     - 用于追加到 `CHKP` 树的 Merkle 证明和用于证明前一个 `CHKP` 叶子的证明。
  2. **证明内容**:
     - “第一部分”证明有效且使用了正确的电路。
     - 前一个区块的 `PsyCheckpointStateTransitionCircuit` 证明有效 (若非创世块)，且其 `new_checkpoint_tree_root` (输出) 与 `previous_block_chkp_root` (当前电路的输入) 以及当前区块 `CHKP` 追加证明的 `old_root` 相匹配。这是**实现递归链式链接的关键**。
     - 新的 `PsyCheckpointLeaf` 被正确计算：
       - `URT`, `GCON`, `GUSR` 的新全局根取自已验证的“第一部分”证明的头部。
       - 其他全局树根 (例如 `GDT`, `GWT`) 要么通过类似的聚合证明进行更新 (为简洁起见此处未详述，但会遵循相似模式)，要么在无变化时被继承。
       - 新的区块统计数据 (结合 GUTA 统计数据与区块时间、随机性等) 被计算。
     - `CHKP` 树的追加操作正确，通过追加新计算的 `PsyCheckpointLeaf` 哈希，从 `previous_block_chkp_root` 转换为 `new_checkpoint_tree_root`。
  3. **此最终证明的公共输入**: `previous_block_chkp_root` 和 `new_checkpoint_tree_root`。
- **输出**: 当前区块的最终区块证明。

**步骤 4.2: 区块最终化与分发**

- **操作**: 协调者从证明矿工网络接收最终的区块证明。
- **过程**:
  1. 协调者验证这个最终证明。
  2. 若有效，此区块即被视为**最终确定**。其 `new_checkpoint_tree_root` 成为该区块高度的规范状态根。
  3. 协调者将此最终区块证明和新的 `CHKP` 根分发到网络中 (其他协调者、Realms、用户)。
  4. Realms 更新它们本地关于最新已最终确定的 `CHKP` 根的视图，用户将使用此视图作为他们下一次用户证明会话的基础。

这个复杂精密的、端到端由 ZK 证明保障的旅程，确保了 Psy 中的每一次状态转换——从单个用户的操作到全局区块状态——都经过密码学的安全保护和验证，同时实现了大规模的并行处理和可扩展性。区块证明的递归验证意味着，只需验证最新的区块证明，就足以信任整条链的完整性。