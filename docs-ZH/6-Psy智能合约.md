# Psy 上的智能合约

关于 Psy 智能合约的高级介绍

Psy 上的智能合约与以太坊等传统区块链上的智能合约有着本质的不同。Psy 独特的 PARTH 状态架构及其与零知识证明 (ZKP) 的原生集成，使得智能合约的定义、执行及其状态管理方式必须采用一种全新的范式。本文档旨在为开发者提供对 Psy 智能合约模式的全面理解。

## Psy 智能合约的核心原则

1. **以用户为中心的状态 (PARTH):**
   - Psy 不为每个智能合约维护一个单一的全局状态树，而是采用 PARTH 模型。对于一个给定的智能合约，**每个与之交互的用户都有其自己独立的 `CSTATE` (合约状态树)**。
   - 这个 `CSTATE` 保存着**仅与该用户**相关的、针对**该特定合约**的存储变量。
   - 用户的 `UCON` (用户合约树) 作为一个目录，将 `合约ID` 映射到其各自 `CSTATE` 树的根。
   - **重要影响:** 用户 A 执行合约 X 会修改用户 A 针对合约 X 的 `CSTATE`。它**不能**直接修改用户 B 针对合约 X 的 `CSTATE`，也不能直接修改合约 X 的任何全局状态（因为传统意义上的“全局合约状态”在这里并不以相同方式存在）。这种隔离是消除写入冲突、实现并行执行的关键。
2. **本地执行与证明:**
   - 智能合约函数（合约函数电路 - CFCs）由**用户在本地**（或通过其客户端软件/代理）在其**用户证明会话 (UPS)** 期间执行。
   - 对于每次本地执行，用户都会生成一个 ZK 证明（CFC 证明），该证明证实了在给定他们该合约的特定起始 `CSTATE` 的情况下，执行是根据合约定义的逻辑正确进行的。
   - **重要影响:** Psy 网络（Realms、Coordinators、证明矿工）**不会**重新执行智能合约逻辑。它只验证用户提交的 ZK 证明。这极大地减轻了网络的计算工作量。
3. **原生 ZK 设计 (Dapen 工具链):**
   - Psy 上的智能合约使用高级语言（例如，一种受 TypeScript/JavaScript 启发的语法）编写，并通过 **Dapen (DPN)** 工具链编译成可验证的 ZK 电路 (CFCs)。
   - 合约逻辑本身被嵌入在这些电路中。
   - **重要影响:** 每次智能合约函数调用本质上都是一个经过 ZK 证明的操作。这带来了强大的隐私性（CFC 的敏感输入无需在链上公开）和可验证的计算。
4. **全局读取访问 (历史状态):**
   - 虽然用户的 CFC 执行只**写入**自己的 `CSTATE`，但它可以**读取**区块链全局状态中**前一个区块**最终化的任何数据。
   - 这包括：
     - 来自 `GUSR` 的其他用户的 `ULEAF` 数据（例如，余额、`UCON` 根）。
     - 另一个用户针对特定合约的 `CSTATE` 根（通过该用户的 `UCON` 根访问）。然后，CFC 可以从 DA 矿工/Realm 请求实际的 `CSTATE` 数据，以基于该历史根执行读取操作。
     - 来自 `GCON` 的全局合约定义 (`CLEAF` 数据)。
   - **重要影响:** 合约可以访问全局信息并作出反应，但由于读取的是历史状态，传统系统中常见的读写竞争条件得以避免。

## 定义一个 Psy 智能合约

一个 Psy 智能合约的定义包含几个组成部分：

**1. 合约逻辑 (源代码):**

- 使用与 Dapen 兼容的高级语言（如 Rust/TypeScript）编写。
- 定义状态变量（它们将存在于每个用户的 `CSTATE` 中）和函数（它们将被编译成 CFCs）。

**2. 编译为 CFCs:**

- Dapen 工具链将每个公共函数（例如 `mint`、`transfer`、`claim`）编译成一个独立的 `DapenContractFunctionCircuit` (CFC)。
- 在编译过程中，Dapen 还会生成：
  - 每个 CFC 的**验证者数据 (Verifier Data)**：验证由该 CFC 生成的 ZK 证明所需的数据。
  - 每个 CFC 的**电路指纹 (Circuit Fingerprint)**：该 CFC 验证者数据的哈希，唯一地标识了电路逻辑。
  - 合约的 **ABI (应用二进制接口)**。

**3. 合约函数树 (CFT):**

- 为每个已部署的合约构建一个 `CFT`。这是一个 Merkle 树。
- `CFT` 的叶子是该合约所有有效的、可执行函数 (CFCs) 的**电路指纹**，通过 `函数ID` 进行映射。
- 该 `CFT` 的根是一个关键的元数据，存储在链上。
- **目的：**CFT 充当着白名单的角色。当用户在本地执行一个 CFC 并提交其证明时，`UPSCFCStandardTransactionCircuit`（在 UPS 过程中）会验证该 CFC 的指纹是否存在于合约的官方 CFT 中（其根是全局 `GCON` 状态的一部分，并锚定于会话的检查点）。这就防止了用户执行任意或未经授权的代码版本。

## 部署智能合约

在 Psy 上部署智能合约涉及将其定义和编译后的组件提交到网络，这些组件随后被记录在全局状态树中。

**流程:**

1. 本地编译:

   开发者使用 Dapen 工具链编译他们的智能合约源代码。这将产生：

   - 每个 CFC 的字节码或定义。
   - 每个 CFC 的验证者数据。
   - 每个 CFC 的电路指纹。
   - 合约的 ABI。

2. **构建 CFT:** 开发者（或部署工具）通过所有合约函数的指纹创建一个 Merkle 树，从而构建出 `CFT`。

3. 准备 CLEAF 数据:

   准备 PsyContractLeaf (CLEAF) 数据。这包括：

   - `deployer_hash`: 部署用户/实体的标识符。
   - `contract_function_tree_root`: 在步骤 2 中构建的 `CFT` 的根。
   - `contract_state_tree_height`: 与此合约关联的、每个用户的 `CSTATE` 树所需的 Merkle 树高度。这决定了该合约每个用户的最大存储槽位数。

4. 提交部署交易:

   部署者发起一个特殊的全局交易（由 Coordinator 编排）来部署合约。

   - **电路:** `BatchDeployContractsCircuit` (由证明矿工执行)。
   - **动作:** 此电路接收一批 `CLEAF` 数据作为输入。
   - **证明内容:**
     - 新的 `CLEAF` 被正确地批量追加到 `GCON` (全局合约树)。
     - 每个提供的 `CLEAF` 见证数据的哈希与实际追加到 `GCON` 的数据相匹配。
     - 该操作遵循 `deploy_contract_circuit_whitelist`（部署合约的电路白名单）。

5. **链上存储 (概念上):**

   - `CLEAF` 数据（包括 `CFT` 根） 作为 `GCON` 中的一个新叶子被存储。`合约ID` 通常是这个叶子在 `GCON` 中的索引。
   - **实际的 CFC 字节码/定义和验证者数据** 通过一个内容可寻址系统提供，通常由 Coordinators 和/或 DA 矿工存储。当用户的客户端需要首次在本地执行某个 CFC 时，会获取这些数据。`CFT` 指纹确保他们获取并执行的是正确的、列入白名单的版本。

## 智能合约执行流程 (回顾)

1. **用户意图:** 用户决定调用一个合约（由 `合约ID` 标识）上的一个函数（例如 `transfer`）。
2. **客户端软件:**
   - 从 `GCON` 获取合约的 `CLEAF`（通过 Realm/Coordinator），以得到 `CFT` 根和 `CSTATE` 高度。
   - 获取目标函数的 CFC 定义/字节码和验证者数据（如果未缓存），并根据 `CFT` 验证其指纹（使用指纹在 `CFT` 中的 Merkle 证明）。
   - 从用户的 `UCON` 中检索该 `合约ID` 对应的当前 `CSTATE` 根（以 UPS 开始或上一步的状态为准）。
   - 如果 CFC 需要读取特定的存储槽位，从 DA 矿工/Realms 检索必要的历史 `CSTATE` 叶子数据。
3. **本地执行 (CFC):**
   - 客户端在本地执行获取的 CFC，提供用户当前的 `CSTATE` 根、函数参数和其他上下文数据（例如 `session_proof_tree_root`）。
   - 生成一个 CFC 证明。
4. **UPS 集成:**
   - CFC 证明由 UPS 内的 `UPSCFCStandardTransactionCircuit`（或类似电路）进行验证。
   - 该电路还会验证：
     - 函数的指纹在合约的官方 `CFT` 中。
     - 用户的 `UCON` 被正确更新，以反映 CFC 产生的新 `CSTATE` 根。
5. **End Cap (封顶) 与提交:** UPS 通过一个 End Cap 证明最终化，并提交给一个 Realm。

## 状态管理与数据可用性

- **`CSTATE` 数据:** 用户针对某个合约的 `CSTATE` 的实际键值对并不直接是 `UCON` 或 `GUSR` 的一部分。只有 `CSTATE` 的**根哈希**存储在 `UCON` 中该合约对应的叶子上。
- **状态增量 (State Deltas):** 当用户提交一个 End Cap 证明时，他们也会提交“状态增量”——即他们 `CSTATE`(s) 中实际发生变化的叶子值。
- **DA 矿工 & Realms:** Realms 接收这些增量，进行存储，并将其转发给 DA 矿工。DA 矿工负责持久化存储这些粒度化的 `CSTATE` 数据，并使其对需要读取它的用户可用（无论是为了未来的交易读取自己的状态，还是读取他人的历史状态）。
- **读取状态:** 当一个 CFC 需要从用户的 `CSTATE` 读取一个值时，客户端会提供该叶子值和一个 Merkle 证明，表明该叶子是给予 CFC 的 `start_contract_state_tree_root` 的一部分。CFC 在使用该值之前会验证这个证明。读取其他用户的历史状态也类似。

## Psy 智能合约模型的影响

- **增强的可扩展性:** 由于用户状态隔离，实现了大规模并行执行。
- **改进的隐私性:** 敏感计算可以在 CFC 内部于本地进行，而无需在链上暴露原始数据。只有正确执行的证明是公开的。
- **可验证的链下计算:** 复杂的逻辑可以在链下（由用户本地）执行，并在链上进行 ZK 验证，减少了链上负载。
- **消除竞争条件:** 本地化写入和历史性全局读取防止了常见的并发问题。
- **用户的 Gas 效率:** 用户的主要“成本”是生成本地证明。网络费用用于证明聚合和数据存储，由于 Psy 的架构，这些费用更稳定，不易受竞价动态影响。一个用户可以将许多本地合约交互捆绑到一个 End Cap 证明中，网络成本主要取决于 End Cap 证明的大小（恒定）以及他们所有交易中修改的独立状态槽位数量。
- **新的设计模式:**
  - **异步交互:** 代币示例中的 `sent_to_others`/`claimed_from_others` 模式是跨用户价值转移的常见模式。用户 A 证明他们已经“发送”（借记自己，记录意图）。用户 B 稍后证明他们“认领”（贷记自己，引用用户 A 记录的发送金额）。
  - **面向代理的编程:** 合约可以被设计成与自主代理（没有私钥的 SDKey 用户）进行交互，这些代理的行为可以通过其签名电路得到可证明的约束。

Psy 的智能合约系统虽然与众不同，但为开发者构建下一代去中心化应用提供了一个强大、可扩展且私密的平台。Dapen 工具链旨在抽象掉大部分底层的 ZK 复杂性，让开发者能够专注于应用逻辑。