# 本地证明 (Local Proving)

关于 Psy 上的本地证明（即用户证明会话/UPS）工作原理的概述。

# Psy 网络：本地用户证明会话 (UPS) 深度剖析

**用户证明会话 (User Proving Session, UPS)** 是 Psy 架构的基石，它使用户能够在本地处理自己的交易、保护隐私，并为网络的整体可扩展性做出贡献。本文档将深入探讨 UPS、其构成电路以及它所提供的密码学保障。对于构建客户端应用、钱包或需要在底层与 Psy 交互的工具的开发者来说，这些信息至关重要。

## 用户证明会话 (UPS) 概述

UPS 是用户（或其代理，如客户端软件）在本地执行的一系列操作，旨在：

1. **建立基线 (Establish a Baseline):** 将会话锚定到 Psy 区块链的一个全局最终化状态。
2. **执行交易 (Execute Transactions):** 为每笔期望的交易运行智能合约函数（合约函数电路 - CFCs）的逻辑。
3. **证明正确性 (Prove Correctness):** 为每次 CFC 执行生成零知识证明 (ZKPs)。
4. **维护状态一致性 (Maintain State Consistency):** 证明用户的本地状态（其 `UCON` 树根、债务树等）根据已执行的 CFC 的结果得到了正确更新。
5. **递归验证 (Recursive Verification):** 将这些证明以递归方式链接在一起，使每一步都验证前一步。
6. **授权 (Authorize):** 使用用户基于 ZK 的签名电路 (SDKey) 对整个会话的结果进行密码学签名。
7. **生成摘要 (Produce a Summary):** 输出一个单一、紧凑的“会话封顶（End Cap）”证明，该证明证实了会话内所有交易的有效性。

这个 End Cap 证明，连同净状态增量（用户 `CSTATE` 叶子的变更），随后被提交给一个 Realm 节点，以包含在下一个区块中。

## UPS 中的关键电路与 Gadget (构件)

UPS 依赖于一套专门的 ZK 电路和 Gadget。 "Gadget" 是可重用的 ZK 电路组件。

### 1. `UPSStartSessionCircuit` - 初始化会话

- **目的：** 安全地初始化 UPS，确保它从一个对用户而言一致且经过全局验证的状态开始。
- **核心 Gadget：** `UPSStartStepGadget`
- **输入/见证数据 (Inputs/Witnesses)** (由用户客户端提供):
  - `UPSStartStepInput`:
    - `header_witness`: 一个目标 `UserProvingSessionHeaderGadget`，电路将填充并约束它。其 `session_start_context` 内的关键字段包括：
      - `checkpoint_tree_root`: 用户此次会话所依据的最后一个全局最终化区块的 `CHKP` 根的哈希。
      - `checkpoint_leaf_hash`: 与 `checkpoint_tree_root` 对应的 `PsyCheckpointLeaf` 的哈希。
      - `checkpoint_id`: 该检查点的区块高度/索引。
      - `start_session_user_leaf`: 用户在该检查点时的 `PsyUserLeaf` 数据。
    - `checkpoint_leaf_gadget_witness`: 实际的 `PsyCheckpointLeafCompactWithStateRoots` 数据。
    - `state_roots_gadget_witness`: 包含在 `checkpoint_leaf_gadget_witness` 中的 `PsyGlobalStateRoots`。
    - `checkpoint_tree_proof_witness`: 一个 Merkle 证明，表明 `checkpoint_leaf_hash` 是在 `checkpoint_id` 处、以 `checkpoint_tree_root` 为根的树中的一个有效叶子。
    - `user_tree_proof_witness`: 一个 Merkle 证明，表明 `start_session_user_leaf` 的哈希是在用户的 `user_id` 处、以 `state_roots_gadget_witness.user_tree_root` 为根的 `GUSR` (全局用户树) 中的一个有效叶子。
- **它证明了什么 (What it Proves):**
  1. **检查点有效性 (Checkpoint Validity):** 所提供的 `checkpoint_leaf_hash` 确实是在指定的 `checkpoint_id` 处、声称的 `checkpoint_tree_root` 的一部分（使用 `checkpoint_tree_proof_witness` 验证）。
  2. **全局上下文一致性 (Global Context Consistency):** `checkpoint_leaf_gadget_witness` 的哈希与 `checkpoint_leaf_hash` 匹配。`state_roots_gadget_witness` 的哈希与 `checkpoint_leaf_gadget_witness` 内的 `global_chain_root` 匹配。
  3. **用户状态有效性 (User State Validity):** 用户的 `start_session_user_leaf` (经哈希后) 是在正确的 `user_id` 处、`GUSR` (根为 `state_roots_gadget_witness.user_tree_root`) 中的一个有效叶子（使用 `user_tree_proof_witness` 验证）。
  4. **头部初始化 (Header Initialization):**
     - 输出的 `UserProvingSessionHeader` 中的 `session_start_context` 被正确地从已验证的输入中填充。
     - 头部内的 `current_state` 被初始化：
       - `user_leaf` 设置为 `start_session_user_leaf`，但其 `last_checkpoint_id` 更新为当前会话的 `checkpoint_id`。
       - `deferred_tx_debt_tree_root` 和 `inline_tx_debt_tree_root` 设置为 `EMPTY_TREE_ROOT`。
       - `tx_count` 设置为 0。
       - `tx_hash_stack` (一个交易的滚动哈希) 设置为 `ZERO_HASH`。
       - `ups_step_circuit_whitelist_root` 为后续的 UPS 步骤电路设置为一个已知常量。
- **输出：** 此启动步骤的 ZK 证明，以及初始化后的 `UserProvingSessionHeader`。
- **重要性：** 此步骤至关重要，可防止用户基于无效或过时的个人状态启动会话。它将整个 UPS 锚定到一个可验证的全局共识点。

### 2. `DapenContractFunctionCircuit` (CFC) - 执行智能合约逻辑

- **目的：** 执行用户选择的特定智能合约函数的逻辑，并为这次本地执行生成一个 ZK 证明。该电路由**智能合约开发者**使用 Dapen 工具链定义。
- **核心 Gadget (框架)：** `PsyContractFunctionBuilderGadget` (由 Dapen 编译器使用)。
- **输入/见证数据** (由用户客户端为每次调用提供):
  - `DapenContractFunctionCircuitInput`:
    - `tx_input_ctx` (交易输入上下文):
      - `transaction_call_start_ctx`: 包含**此次特定合约交互**的**假定**起始状态：
        - `start_contract_state_tree_root`: 在此函数调用之前，用户此合约的 `CSTATE` 树的根（源自前一个 UPS 步骤中的用户 `UCON`）。
        - `start_user_balance`, `start_user_event_index`。
        - `start_deferred_tx_debt_tree_root`, `start_inline_tx_debt_tree_root` (来自前一个 UPS 步骤)。
      - `call_data_hash`, `call_data_length`: 函数参数的哈希和长度。
      - `contract_id`, `method_id`。
    - `circuit_inputs`: 智能合约函数的实际参数。
    - `session_proof_tree_root`: 用户在此 UPS 内到目前为止构建的递归证明树的根。这用于“proof-tree aware（树感知）”证明，确保此 CFC 证明是更大会话证明结构的一部分。
- **它证明了什么:**
  1. **忠实执行 (Faithful Execution):** 电路执行的内部操作序列与编译后的 `DPNFunctionCircuitDefinition` (该函数的智能合约代码) 完全匹配。
  2. **状态转换 (State Transformation):** 给定 `transaction_call_start_ctx` 和 `circuit_inputs`，执行正确地产生了记录在输出 `transaction_end_ctx` 中的 `end_contract_state_tree_root` (用户此合约 `CSTATE` 的新根) 和 `end_deferred_tx_debt_tree_root`。
  3. **输出一致性 (Output Consistency):** 计算出的 `outputs_hash` 和 `outputs_length` (来自函数的返回值) 与 `transaction_end_ctx` 中记录的相匹配。
  4. **断言 (Assertions):** 智能合约函数代码中定义的所有断言在此次执行期间都为真。
  5. **公共输入哈希 (Public Input Hashing):** 电路的主要公共输入（一个结合了 `session_proof_tree_root` 和 `tx_input_ctx` 哈希的值）被正确计算。
- **输出：** 此次特定 CFC 执行实例的 ZK 证明 (CFC 证明)。
- **重要性：** 这是实际运行智能合约逻辑的地方。其 ZK 证明保证了用户的本地执行根据合约代码是正确的，如果合约设计为保护隐私，则无需透露中间状态或输入。

### 3. `UPSCFCStandardTransactionCircuit` - 集成一次 CFC 执行

- **目的：** 接收一个已验证的 CFC 证明（来自步骤 2），并将其效果集成到主 UPS 证明链中。它验证 CFC 的有效性，并证明整个 UPS 状态（用户的 `UCON` 根、债务树、交易计数器）被正确更新。它还递归地验证来自前一个 UPS 步骤的证明。
- **核心 Gadgets:**
  - `VerifyPreviousUPSStepProofInProofTreeGadget`: 验证紧邻的前一个 UPS 步骤的 ZK 证明。
  - `UPSVerifyCFCProofExistsAndValidGadget`: 验证 CFC 证明（来自步骤 2）、其在会话证明树中的包含关系，以及所调用的函数是否在合约的 `CFT` 中全局注册。
  - `UPSCFCStandardStateDeltaGadget`: 计算并证明对 `UserProvingSessionHeader` 的变更。
- **输入/见证数据** (由用户客户端提供):
  - `UPSVerifyCFCStandardStepInput`:
    - 前一个 UPS 步骤的 ZK 证明。
    - 前一个 UPS 步骤输出的 `UserProvingSessionHeaderGadget`。
    - CFC 证明（来自步骤 2）及其 `transaction_end_ctx`。
    - `PsyContractFunctionInclusionProof`: 一个 Merkle 证明，表明 CFC 的指纹在合约的 `CFT` 中（`CFT` 根在 `GCON` 中，`GCON` 锚定于会话的 `checkpoint_leaf_hash`）。
    - `user_contract_tree_update_proof`: 一个 `DeltaMerkleProofCore`，用于证明对用户 `UCON` 树的更新。这显示了在 `contract_id` 处的叶子从 `start_contract_state_tree_root` (来自 CFC 的 `start_ctx`) 变为 `end_contract_state_tree_root` (来自 CFC 的 `end_ctx`)。
    - `deferred_tx_debt_pivot_proof`, `inline_tx_debt_pivot_proof`: `MerkleProofCore` 证明，表明债务树根从它们在前一个 UPS 头部中的状态正确地过渡到它们在 CFC 的 `end_ctx` 中的状态。
  - `current_proof_tree_root`: 在包含当前 CFC 证明和此步骤证明**之后**的 UPS 证明树的根。
- **它证明了什么:**
  1. **前一步骤有效性 (Previous Step Validity):** 前一个 UPS 步骤的证明是有效的，由一个白名单中的 UPS 电路生成，并且其公共输入与前一个 `UserProvingSessionHeader` 的哈希匹配。
  2. **CFC 有效性与合法性 (CFC Validity & Legitimacy):**
     - CFC 证明是有效的，并且是 `current_proof_tree_root` 的一部分。
     - 由 CFC 执行的函数是合法的（其指纹在合约的 `CFT` 中，而 `CFT` 是由 `previous_step_header.session_start_context.checkpoint_leaf_hash` 引用的全局状态的一部分）。
     - 来自已验证 CFC 证明的 `cfc_inner_public_inputs_hash`（源自 CFC 的 `tx_input_ctx`）与 `UPSCFCStandardStateDeltaGadget` 使用的相匹配。这是一个**关键链接**，确保状态增量计算基于**实际经过验证的计算**。
  3. **状态增量正确性 (State Delta Correctness)** (通过 `UPSCFCStandardStateDeltaGadget`):
     - **`UCON` 更新:** `user_contract_tree_update_proof` 正确地将 `UCON` 根从 `previous_step_header.current_state.user_leaf.user_state_tree_root` 更新为一个新根，该新根反映了 `contract_id` 从 `start_contract_state_tree_root` 变为 `end_contract_state_tree_root` 的变更。
     - **债务树一致性:** `deferred/inline_tx_debt_pivot_proofs` 表明，CFC 的 `end_ctx` 中的债务树根是 `previous_step_header` 中债务树根的有效后继者（如果被覆盖，则为 `CorrectUPSHeaderHashesGadget`）。
     - **计数器与堆栈:** 新头部中的 `tx_count` 增加。`tx_hash_stack` 通过将前一个堆栈与一个 `TransactionLogStackItemGadget` (包含 CFC 调用详情) 进行哈希来更新。
     - 新头部中的 `current_state.user_leaf` 被更新（例如，`user_state_tree_root` 现在反映了新的 `UCON` 根）。
- **输出：** 此交易步骤的 ZK 证明，以及新的 `UserProvingSessionHeaderGadget`。
- **重要性：** 这是 UPS 的主力电路，它以可验证、递归的方式，细致地将单个合约执行与用户的整体会话状态链接起来。

*(步骤 2 和 3 会为用户希望包含在其会话中的每笔交易重复执行。)*

### 4. `UPSStandardEndCapCircuit` - 最终化会话

- **目的：** 安全地结束 UPS，生成单一的 End Cap 证明。它验证本地证明的整个链条，验证用户授权会话的 ZK 签名，并确保会话在一个定义的、干净的状态下终止。
- **核心 Gadgets:**
  - `UPSEndCapFromProofTreeGadget`: 协调最终的验证。
    - 内部使用 `VerifyPreviousUPSStepProofInProofTreeGadget` (通常是 `PartialFromCurrent` 变体) 来验证最后一个交易步骤的证明。
    - 使用 `AttestProofInTreeGadget` 来验证用户的 ZK 签名证明及其在会话证明树中的包含关系。
  - `UPSEndCapCoreGadget`: 强制执行最终的会话约束。
- **输入/见证数据** (由用户客户端提供):
  - `UPSEndCapFromProofTreeInput`:
    - 用于验证最后一个 UPS 交易步骤证明的见证数据（证明、前一状态、白名单证明）。
    - 用于验证 ZK 签名证明的见证数据（证明、签名电路的公钥参数）。
    - `user_public_key_param`: 用户定义的其 SDKey 的参数部分。
    - `nonce`: 用户的新 nonce 值。
    - `slots_modified`: 修改的状态槽位数（用于统计）。
  - ZK 签名证明本身。该证明由用户选择的签名电路生成。签名电路的公共输入是一个从 `PsyUserProvingSessionSignatureDataCompactGadget` 派生出的 sighash。
  - `PsyUserProvingSessionSignatureDataCompactGadget` (见证数据): 包含 `start_user_leaf_hash`、`end_user_leaf_hash` (来自最终的 `UserProvingSessionHeader`)、`checkpoint_leaf_hash` (来自会话开始)、`tx_stack_hash` 和 `tx_count` (来自最终头部)。
- **它证明了什么** (通过 `UPSEndCapCoreGadget` 及其组成部分):
  1. **最后步骤有效性 (Last Step Validity):** UPS 中最后一个交易步骤的证明是有效的，并且使用了一个白名单中的 UPS 电路。
  2. **签名证明有效性 (Signature Proof Validity):** 所提供的 ZK 签名证明是有效的，并且与最后一个交易步骤在同一个会话证明树中。
  3. **授权 (Authorization):**
     - 签名电路的指纹（来自 `sig_proof_verifier_data`）与 `user_public_key_param` 相结合，正确地重构出用户注册的公钥（该公钥存在于最终 `UserProvingSessionHeader` 内的 `start_user_leaf` 和 `end_user_leaf` 中）。
     - ZK 签名证明的公共输入与从 `PsyUserProvingSessionSignatureDataCompactGadget` 见证数据计算出的 sighash 相匹配，而该见证数据又源自 `UserProvingSessionHeader` 的最终状态。这确认了该签名授权了**此次特定会话的结果**。
  4. **Nonce 递增 (Nonce Progression):** `nonce` 见证数据大于 `last_header_gadget.current_state.user_leaf.nonce` (来自会话开始时)，并且 `end_user_leaf.nonce` 更新为这个新的 `nonce`。
  5. **检查点递增 (Checkpoint Progression):** `last_header_gadget.current_state.user_leaf.last_checkpoint_id` 更新为 `last_header_gadget.session_start_context.checkpoint_id` (并且这必须大于原始的 `last_checkpoint_id`)。
  6. **干净状态 (Clean State):** `last_header_gadget.current_state` 中的 `deferred_tx_debt_tree_root` 和 `inline_tx_debt_tree_root` 均为 `EMPTY_TREE_ROOT`。
  7. **输出生成 (Output Generation):**
     - `UPSEndCapResultCompactGadget` 使用 `start_user_leaf_hash`、`end_user_leaf_hash`、`checkpoint_tree_root_hash` (来自会话开始上下文) 和 `user_id` 正确构成。其哈希是一个公共输出。
     - `GUTAStatsGadget` 正确构成（费用、交易计数、修改的槽位数）。其哈希是一个公共输出。
- **输出：** End Cap ZK 证明。其公共输入是 `end_cap_result_hash` 和 `guta_stats_hash`。
- **重要性：** 这是用户本地工作的结晶。End Cap 证明是对用户在该区块中所有行为的一个紧凑、可验证的断言，已准备好供 Psy 网络高效处理。

## UPS 证明树

在整个 UPS 期间，一个本地的 Merkle 证明树被隐式地构建起来。

- 该树的叶子是单个 CFC 执行的 ZK 证明和 ZK 签名证明。
- 中间节点是来自 `UPSCFCStandardTransactionCircuit` (或其变体) 和 `UPSStartSessionCircuit` 的 ZK 证明。
- 该树的根由各种 Gadget 中的 `current_proof_tree_root` 引用，并通过递归验证链被隐式验证。`UPSEndCapCircuit` 可以选择性地包含对此树聚合的显式证明，以应对某些高级场景或跨 UPS 交互，但通常递归验证就足够了。

通过将交易执行和初始证明生成卸载给用户，UPS 极大地减少了主 Psy 网络的计算负载，使其能够专注于聚合和维护全局共识。这种本地优先的方法是 Psy 隐私、可扩展性和以用户为中心设计的基础。